from flask import Blueprint, jsonify, request, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from src.models.user import User, Job
from src.models.authority_to_act import AuthorityToActToken
from src.extensions import db
from datetime import datetime, timedelta
import logging

authority_bp = Blueprint('authority', __name__)
logger = logging.getLogger(__name__)


def require_admin():
    """Helper function to require admin role."""
    try:
        current_user_id = get_jwt_identity()
        user = User.query.get(current_user_id)
        if not user or user.role not in ['admin', 'manager']:
            return None
        return user
    except Exception:
        return None


@authority_bp.route('/admin/authority-to-act/generate-link', methods=['POST'])
@jwt_required()
def generate_authority_link():
    """Generate a unique link for Authority to Act form."""
    try:
        user = require_admin()
        if not user:
            return jsonify({"error": "Forbidden"}), 403

        data = request.get_json() or {}
        job_id = data.get('job_id')
        client_name = data.get('client_name')
        client_email = data.get('client_email')
        property_address = data.get('property_address')
        expires_in_days = data.get('expires_in_days', 30)  # Default 30 days

        # Validate job if provided
        if job_id:
            job = Job.query.get(job_id)
            if not job:
                return jsonify({"error": "Job not found"}), 404

        # Generate unique token
        token = AuthorityToActToken.generate_token()

        # Calculate expiration
        expires_at = datetime.utcnow() + timedelta(days=expires_in_days) if expires_in_days else None

        # Create token record
        auth_token = AuthorityToActToken(
            token=token,
            job_id=job_id,
            created_by=user.id,
            client_name=client_name,
            client_email=client_email,
            property_address=property_address,
            status='pending',
            expires_at=expires_at
        )

        db.session.add(auth_token)
        db.session.commit()

        # Generate public URL
        base_url = current_app.config.get('PUBLIC_BASE_URL', 'https://v3-app.herokuapp.com')
        public_url = f"{base_url}/public/authority-to-act/{token}"

        logger.info(f"Authority to Act link generated by admin {user.id} for job {job_id}")

        return jsonify({
            'id': auth_token.id,
            'token': token,
            'url': public_url,
            'expires_at': auth_token.expires_at.isoformat() if auth_token.expires_at else None,
            'message': 'Link generated successfully'
        }), 201

    except Exception as e:
        logger.error(f"Error generating authority link: {e}")
        db.session.rollback()
        return jsonify({"error": "Internal server error"}), 500


@authority_bp.route('/admin/authority-to-act/links', methods=['GET'])
@jwt_required()
def list_authority_links():
    """List all Authority to Act links created by admin."""
    try:
        user = require_admin()
        if not user:
            return jsonify({"error": "Forbidden"}), 403

        # Get optional filters
        status = request.args.get('status')  # pending, submitted, expired
        job_id = request.args.get('job_id')

        query = AuthorityToActToken.query

        if status:
            query = query.filter_by(status=status)
        if job_id:
            query = query.filter_by(job_id=job_id)

        links = query.order_by(AuthorityToActToken.created_at.desc()).all()

        result = []
        for link in links:
            link_data = link.to_dict()
            link_data['url'] = f"{current_app.config.get('PUBLIC_BASE_URL')}/public/authority-to-act/{link.token}"
            link_data['is_valid'] = link.is_valid()
            result.append(link_data)

        return jsonify({'links': result}), 200

    except Exception as e:
        logger.error(f"Error listing authority links: {e}")
        return jsonify({"error": "Internal server error"}), 500


@authority_bp.route('/public/authority-to-act/<token>', methods=['GET'])
def get_authority_form_data(token):
    """Get form data for a specific token (public endpoint, no auth required)."""
    try:
        auth_token = AuthorityToActToken.query.filter_by(token=token).first()

        if not auth_token:
            return jsonify({"error": "Invalid or expired link"}), 404

        if not auth_token.is_valid():
            return jsonify({"error": "This link has expired or has already been used"}), 410

        # Return pre-filled data (if any)
        return jsonify({
            'token': auth_token.token,
            'client_name': auth_token.client_name,
            'client_email': auth_token.client_email,
            'property_address': auth_token.property_address,
            'status': auth_token.status,
        }), 200

    except Exception as e:
        logger.error(f"Error fetching authority form data: {e}")
        return jsonify({"error": "Internal server error"}), 500


@authority_bp.route('/public/authority-to-act/<token>/submit', methods=['POST'])
def submit_authority_form(token):
    """Submit Authority to Act form (public endpoint, no auth required)."""
    try:
        auth_token = AuthorityToActToken.query.filter_by(token=token).first()

        if not auth_token:
            return jsonify({"error": "Invalid or expired link"}), 404

        if not auth_token.is_valid():
            return jsonify({"error": "This link has expired or has already been used"}), 410

        data = request.get_json() or {}

        # Update token with submission data
        auth_token.status = 'submitted'
        auth_token.submitted_at = datetime.utcnow()
        auth_token.submission_data = data

        db.session.commit()

        logger.info(f"Authority to Act form submitted for token {token}")

        # Send Telegram notification to admin group
        try:
            from src.integrations.telegram_client import send_telegram_notification

            client_name = data.get('client_name', 'Unknown')
            property_address = data.get('property_address', 'Not specified')

            message = (
                f"ðŸ”” *New Authority to Act Form Submitted*\n\n"
                f"*Client:* {client_name}\n"
                f"*Property:* {property_address}\n"
                f"*Submitted:* {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}\n\n"
                f"View full details in the admin dashboard."
            )

            send_telegram_notification(message, parse_mode='Markdown')
            logger.info("Telegram notification sent for Authority to Act submission")

        except Exception as telegram_error:
            logger.error(f"Failed to send Telegram notification: {telegram_error}")
            # Don't fail the submission if Telegram fails

        return jsonify({
            'message': 'Form submitted successfully',
            'submission_id': auth_token.id
        }), 200

    except Exception as e:
        logger.error(f"Error submitting authority form: {e}")
        db.session.rollback()
        return jsonify({"error": "Internal server error"}), 500


@authority_bp.route('/admin/authority-to-act/<int:link_id>', methods=['GET'])
@jwt_required()
def get_authority_submission(link_id):
    """Get details of a specific Authority to Act submission (admin only)."""
    try:
        user = require_admin()
        if not user:
            return jsonify({"error": "Forbidden"}), 403

        auth_token = AuthorityToActToken.query.get(link_id)

        if not auth_token:
            return jsonify({"error": "Not found"}), 404

        result = auth_token.to_dict()
        result['submission_data'] = auth_token.submission_data
        result['url'] = f"{current_app.config.get('PUBLIC_BASE_URL')}/public/authority-to-act/{auth_token.token}"
        result['is_valid'] = auth_token.is_valid()

        return jsonify(result), 200

    except Exception as e:
        logger.error(f"Error fetching authority submission: {e}")
        return jsonify({"error": "Internal server error"}), 500
